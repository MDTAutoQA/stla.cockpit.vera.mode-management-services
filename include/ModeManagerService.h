/*
 * Copyright (C) 2021 Stellantis/MobileDrive and/or their affiliated companies. All rights reserved.
 *
 * This software, including documentation, is protected by copyright and controlled by
 * Stellantis/MobileDrive. All rights are reserved. Copying, including reproducing, storing,
 * adapting or translating any or all of this material requires the prior written
 * consent of Stellantis/MobileDrive jointly. This material also contains confidential information,
 * which may not be disclosed to others without the prior and joint written consent of Stellantis/MobileDrive.
 *
 * ****** About File **********
 * contains the LCM service application logic.
 */

#ifndef ModeManager_SERVICE_H
#define ModeManager_SERVICE_H

// Include the ModeManager service interface generated by IPCF
#include <IModeManagerService.h>

// Include the enum define
#include <ModeManagerServiceTypes.h>

// Include the IPCF connection delegate interface
#include <orpheus/framework/ipcf/service-callbacks/IConnectionEventDelegate.h>

#include <cJSON/cJSON.h>
#include <fstream>
#include <string>
#include <filesystem>

#include <apmf/ptr.h>
#include <apmf/process.h>
#include <apmf/apmf_base.h>
#include <apmf/iface/com/amazon/apmf/IProcess.h>

// Include the CarPlay service and AndroidAuto service interface
#include <apmf/iface/com/stellantis/projectionIface/carplay/ICarPlayClientFactory.h>
#include <apmf/iface/com/stellantis/projectionIface/carplay/ICarPlayClient.h>
#include <apmf/iface/com/stellantis/projectionIface/androidAuto/IAndroidAutoClientFactory.h>
#include <apmf/iface/com/stellantis/projectionIface/androidAuto/IAndroidAutoClient.h>

namespace orpheus::service::ModeManagerService
{
    /**
     * @brief ModeManager Service class that implements the APIs supported over IPC
     *
     */
    class ModeManagerService : public IModeManagerService, public orpheus::framework::ipcf::IConnectionEventDelegate
    {
    public:
        /**
         * @class StateSubscriberData
         * @brief State Callback Subscriber Data
         *
         */
        class StateSubscriberData final
        {
        private:
            /**
             * @brief Callback for state event
             *
             */
            onStateCallback callback;
            /**
             * @brief Context for state event
             *
             */
            void *context;

        public:
            /**
             * @brief Delete default constructor
             * 
             */
            StateSubscriberData() = delete;

            /**
             * @brief Construct a new State Subscriber Data object
             *
             * @param cb
             * @param ctx
             */
            StateSubscriberData(onStateCallback cb, void *ctx) : callback(cb), context(ctx) {}

            /**
             * @brief Destroy the State Subscriber Data object
             *
             */
            ~StateSubscriberData() = default;

            /**
             * @brief Get the Callback object
             *
             * @return onStateCallback
             */
            onStateCallback getCallback() const noexcept { return callback; }

            /**
             * @brief Get the Context object
             *
             * @return void*
             */
            void *getContext() const noexcept { return context; }
        };

        /**
         * @class BackStackSubscriberData
         * @brief Back Stack Callback Subscriber Data
         *
         */
        class BackStackSubscriberData final
        {
        private:
            /**
             * @brief Callback for back stack event
             *
             */
            onBackStackCallback callback;
            /**
             * @brief Context for back stack event
             *
             */
            void *context;

        public:
            /**
             * @brief Delete default constructor
             *
             */
            BackStackSubscriberData() = delete;

            /**
             * @brief Construct a new Back Stack Subscriber Data object
             *
             * @param cb
             * @param ctx
             */

            BackStackSubscriberData(onBackStackCallback cb, void *ctx) : callback(cb), context(ctx) {}

            /**
             * @brief Destroy the Back Stack Subscriber Data object
             *
             */
            ~BackStackSubscriberData() = default;

            /**
             * @brief Get the Callback object
             *
             * @return onBackStackCallback
             */
            onBackStackCallback getCallback() const noexcept { return callback; }

            /**
             * @brief Get the Context object
             *
             * @return void*
             */
            void *getContext() const noexcept { return context; }
        };

        /**
         * @brief Construct a new Mode Manager Service object
         *
         */
        ModeManagerService();

        /**
         * @brief Destroy the Mode Manager Service object
         *
         */
        ~ModeManagerService() override;

        /**
         * @brief Delete the copy constructor
         * 
         */
        ModeManagerService(const ModeManagerService &) = delete;

        /**
         * @brief // Delete the copy assignment operator
         * 
         * @return ModeManagerService& 
         */
        ModeManagerService &operator=(const ModeManagerService &) = delete;

        /**
         * @brief Delete the move constructor
         * 
         */
        ModeManagerService(const ModeManagerService &&) = delete;

        /**
         * @brief Delete the move assignment operator
         * 
         * @return ModeManagerService& 
         */
        ModeManagerService &operator=(const ModeManagerService &&) = delete;

        /**
         * @brief Get the Instance object
         *
         * @return ModeManagerService&
         */
        static ModeManagerService &getInstance();

        /**
         * @brief API to update current mode with the given component.
         *
         * @param[in] componentId   App ID or ComponentID (OneUnity component)
         * @param[in] path          Path data for an OneUnity component
         * @return int32_t  0 for success. Any other value is an error.
         */
        int32_t requestModeUpdate(std::string &componentId, std::string &path) override;

        /**
         * @brief API to set request transient mode update.
         *
         * @param[in] componentId   App ID or ComponentID (OneUnity component)
         * @return int32_t  0 for success. Any other value is an error.
         */
        int32_t requestTransientModeUpdate(std::string &componentId) override;

        /**
         * @brief API to switch back to the last mode
         *
         * @return int32_t  0 for success. Any other value is an error.
         */
        int32_t popBackStack() override;

        /**
         * @brief API to set pending request with the given component.
         *
         * @param[in] componentId   App ID or ComponentID (OneUnity component)
         * @return int32_t  0 for success. Any other value is an error.
         */
        int32_t setPendingRequest(std::string &componentId) override;

        /**
         * @brief API to request launch params with the given component.
         *
         * @param[in] componentId   App ID or ComponentID (OneUnity component)
         * @param[in] requestUuid   Universally Unique Identifier
         * @param[in] callback      Callback to be invoked with the result of the addition
         * @param[in] result_ctx    Context that is passed back with the result callback
         * @return int32_t  0 for success. Any other value is an error.
         */
        int32_t iRequestLaunchParams(std::string &componentId, std::string &requestUuid, onLaunchParamCallback callback, void *result_ctx) override;

        /**
         * @brief API to subscribe state event
         *
         * @param[in] callback  Callback to be invoked with the result of the addition
         * @param[in] ctx       Context that is passed back with the result callback
         * @return int32_t  0 for success. Any other value is an error.
         */
        int32_t stateSubscribe(onStateCallback callback, void *ctx) override;

        /**
         * @brief API to unsubscribe state event
         *
         * @return int32_t  0 for success. Any other value is an error.
         */
        int32_t stateUnsubscribe() override;

        /**
         * @brief API to subscribe back stack event
         *
         * @param[in] callback  Callback to be invoked with the result of the addition
         * @param[in] ctx       Context that is passed back with the result callback
         * @return int32_t  0 for success. Any other value is an error.
         */
        int32_t backStackSubscribe(onBackStackCallback callback, void *ctx) override;

        /**
         * @brief API to unsubscribe back stack event
         *
         * @return int32_t Status code for the operation
         */
        int32_t backStackUnsubscribe() override;

        /**
         * @brief Called when client connects.
         *
         * @param id
         */
        void onConnect(uint16_t id) override;

        /**
         * @brief Called when client disconnects.
         *
         * @param id
         */
        void onDisconnect(uint16_t id) override;

    private:
        /// @brief Process Object
        apmf::Ptr<apmf::iface::com::amazon::apmf::IProcess> process{nullptr};
        /// @brief CarPlay Client Object
        apmf::Ptr<apmf::iface::com::stellantis::projectionIface::carplay::ICarPlayClient> carPlayClient{nullptr};
        /// @brief Android Auto Client Object
        apmf::Ptr<apmf::iface::com::stellantis::projectionIface::androidAuto::IAndroidAutoClient> androidAutoClient{nullptr};
        /// @brief HMI Mode data path
        std::string const FILEPATH{"data/recent_app.json"};
        /// @brief Default home
        std::string const HMI_MODE_DEFAULT_HOME{"HMI_MODE_DEFAULT_HOME"};
        /// @brief Home ID
        std::string const HMI_MODE_HOME_ID{"com.amazon.layout.launcher"};
        /// @brief Foreground App ID
        std::string const HMI_MODE_FOREGROUND_ID{"com.stellantis.oneunity.main"};
        /// @brief Projection Demo App ID
        std::string const PROJECTION_DEMO{"com.amazon.vui-demo-abi.main"};
        /// @brief CarPlay Service ID
        std::string const CAR_PLAY_ID{"com.stellantis.carplay.main"};
        /// @brief Android Auto Service ID
        std::string const ANDROID_AUTO_ID{"com.stellantis.androidauto.main"};
        /// @brief APL Card ID
        std::string const APL_CARD_ID{"com.amazon.arol.interactive"};
        /// @brief Popup Component ID
        std::string const POPUP_COMPONENT_ID{"com.stellantis.notification.main"};
        /// @brief ID
        std::string const KEY_COMPONENT_ID{"id"};
        /// @brief Path
        std::string const KEY_PATH{"path"};
        /// @brief OneUnity
        std::string const KEY_ONEUNITY{"OneUnity"};
        /// @brief Transient Mode
        std::string transientMode{""};
        /// @brief State Subscribers
        std::unordered_map<uint16_t, StateSubscriberData> m_clientStateSubscriptions;
        /// @brief Back Stack Subscribers
        std::unordered_map<uint16_t, BackStackSubscriberData> m_clientBackStackSubscriptions;

        /**
         * @brief Notify the state event subscribers
         *
         * @param[in] state
         * @param[in] errorMsg
         */
        void notifyStateSubscribers(StateOperation &state, std::string &errorMsg);

        /**
         * @brief Notify the back stack event subscribers
         *
         * @param[in] componentId
         * @param[in] path
         * @param[in] errorMsg
         */
        void notifyBackStackSubscribers(std::string &componentId, std::string &path, std::string &errorMsg);

        /**
         * @brief Process the Transient mode
         *
         * @param[in] componentId
         * @return int32_t 0 for success. Any other value is an error.
         */
        int32_t processTransientMode(std::string const &componentId);

        /**
         * @brief Remove the component from JSON
         *
         * @param[in] root
         * @param[in] componentId
         */
        void removeComponentFromJson(cJSON *root, std::string const &componentId) const;

        /**
         * @brief Update the HMI mode
         *
         * @param[in] componentId
         * @param[in] path
         * @param[out] errorMsg
         * @return true
         * @return false
         */
        bool updateHMIMode(std::string &componentId, std::string &path, std::string &errorMsg) const;

        /**
         * @brief Remove the HMI mode
         *
         * @param[in] componentId
         * @param[out] errorMsg
         * @return true
         * @return false
         */
        bool removeHMIMode(std::string const &componentId, std::string &errorMsg) const;

        /**
         * @brief Get the Last Hmi Mode object
         *
         * @param[out] componentId
         * @param[out] path
         * @param[in] lastIndex
         * @return true
         * @return false
         */
        bool getLastHmiMode(std::string &componentId, std::string &path, int32_t lastIndex = 0) const;

        /**
         * @brief Check whether the component is Home
         *
         * @param[in] componentId
         * @return true
         * @return false
         */
        bool isHome(std::string componentId) const;

        /**
         * @brief Check whether the component is same
         *
         * @param[in] componentA
         * @param[in] componentB
         * @param[in] matchedParameters
         * @return true
         * @return false
         */
        bool isSameComponent(std::string componentA, std::string componentB, bool matchedParameters) const;

        /**
         * @brief Check whether the item is OneUnity item
         *
         * @param[in] item
         * @return true
         * @return false
         */
        bool isOneUnityItem(cJSON const *item) const;

        /**
         * @brief Get the Launch Param object
         *
         * @param[in] componentId
         * @return std::string
         */
        std::string getLaunchParam(std::string const &componentId);

        /**
         * @brief Get the current mode
         *
         * @return std::string
         */
        std::string retrieveCurrentMode() const;

        /**
         * @brief Initialize the CarPlay module
         *
         * @return true
         * @return false
         */
        bool initAndCheckCarPlayModule();

        /**
         * @brief Inital the Android Auto module
         *
         * @return true
         * @return false
         */
        bool initAndCheckAndroidAutoModule();

        /**
         * @brief Notify CarPlay and Android Auto screen transition during mode update
         * 
         */
        void handleProjectionDuringModeUpdate();

        /**
         * @brief  Notify the CarPlay screen transition type
         *
         * @param[in] screenType
         * @param[in] status
         * @return CarPlay::ERROR_ID_E
         */
        apmf::iface::com::stellantis::projectionIface::carplay::ERROR_ID_E notifyCarPlayScreenTransitionType(apmf::iface::com::stellantis::projectionIface::carplay::SCREEN_TYPE_E screenType, bool status);

        /**
         * @brief Notify the Android Auto screen transition type
         *
         * @param[in] screenType
         * @return AndroidAuto::ERROR_ID_E
         */
        apmf::iface::com::stellantis::projectionIface::androidAuto::ERROR_ID_E notifyAndroidAutoScreenTransitionType(apmf::iface::com::stellantis::projectionIface::androidAuto::SCREEN_TYPE_E screenType);

        /**
         * @brief Notify the CarPlay user screen transition
         *
         * @param[in] lastMode
         * @return CarPlay::ERROR_ID_E
         */
        apmf::iface::com::stellantis::projectionIface::carplay::ERROR_ID_E notifyCarPlayUserScreenTransition(apmf::iface::com::stellantis::projectionIface::carplay::LASTMODE_E lastMode);

        /**
         * @brief Notify the Android Auto user screen transition
         *
         * @param[in] lastMode
         * @return AndroidAuto::ERROR_ID_E
         */
        apmf::iface::com::stellantis::projectionIface::androidAuto::ERROR_ID_E notifyAndroidAutoUserScreenTransition(apmf::iface::com::stellantis::projectionIface::androidAuto::LASTMODE_E lastMode);

        /**
         * @brief Notify CarPlay screen transition
         *
         * @param[in] componentId
         */
        void handleCarPlayNotification(std::string const &componentId);

        /**
         * @brief Notify AndroidAuto screen transition
         *
         * @param[in] componentId
         */
        void handleAndroidAutoNotification(std::string const &componentId);
    };

} // namespace orpheus::sample::ModeManagerService

#endif // ModeManager_SERVICE_H
